# EventInjection Branch

Event injection allows hypervisors to deliver an event to the guest IDT upon VM-entry. This can because especially useful for emulating instructions that would otherwise interact with the VMM via VM-exits. In our case, our hypervisor doesn't support nest virtualization, and as an example will perform event injection on the sight of VM-exits generated from `VMLAUNCH` instructions. Normally, executing a `VMLAUNCH` instruction inside of VMX operation would generate a VM-exit, and the behavior after that point is dependent upon the hypervisor. When outside of VMX operation, however, `VMLAUNCH` instructions generate invalid opcode exceptions (#UD). The code in this repository will emulate `VMLAUNCH` instructions in such a way that these invalid opcode exceptions are generated. This is done by setting a VMCS control called the interrupt information field (0x4016). This field contains a vector indicating which IDT handler should receive execution following VM-entry. For invalid opcode exceptions, we set this vector to six, transferring control to the IDT entry corresponding to invalid opcode exceptions (`KiInvalidOpcodeFaultShadow`), which gathers some information, and attempts to locate an exception handler setup by our guest software. This processes succeeds, and the guest status variables are set accordingly. This behavior can be seen in the VMM's `VMLAUNCH` handler (line 56), as well as the guest software routine (line 22).

The whole point of this project was to allow users access to a sort of playground (as the name suggests), where one could demo features of VT-x; and sadly I'm uncertain if this branch accomplishes that goal. The tree of calls that digest IDT events in Windows will conduct certain security checks on the current thread, and because of the structure of our project, some of these security checks fail. Specifically, in the case of entry at `KiInvalidOpcodeFaultShadow`, Windows will check the bounds of the faulting stack pointer in accordance with the current thread's initial stack base and limit pair. And because we are using the `DriverEntry` thread, which had a different stack initially, as opposed to a dedicated guest software thread, we fail these sorts of checks. After several hours of reverse engineering, I was able to get the #UD handler to successfully digest and dispatch exceptions to the guest handler (workaround seen in the `SwitchPrcbStackEntries` and `GetPrcbStackEntries` functions), but this process appears to be different for different IDT entries, and creating workarounds for all of them I believe is out of the scope of this project. As it stands, this project successfully demonstrates event injection for generating invalid opcode exceptions, and digesting that behavior in the guest. It serves as a simplistic example of event injection.

There are also other possibilities for event injection, such as injecting breakpoints into guest software, or single stepping via MTF VM-exits.

[Compare this branch to it's base \(GuestState\)](https://github.com/calware/HV-Playground/compare/GuestState...EventInjection)
